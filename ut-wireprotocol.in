#include "frob.h"
#include "utils.h"
#include "log.h"

#define CK_MAX_ASSERT_MEM_PRINT_SIZE 256
#include <check.h>
#include <errno.h>

#define OFFSET_OR_PTR(Start, Value)\
    _Generic((Value),\
        int: (Start) + (intptr_t)(Value),\
        size_t: (Start) + (intptr_t)(Value),\
        void*: (Value)\
    )

#define TEST_HEADER1(Input, ExpectedRet)\
    TEST_HEADER3(Input, ExpectedRet, 0, "")
#define TEST_HEADER3(Input, ExpectedRet, ExpectedType, ExpectedToken)\
    test_header(elementsof(Input), (byte_t*)Input, ExpectedRet, ExpectedType, ExpectedToken)
static void test_header(const size_t bs, const byte_t buf[static bs],
                        const int expected_return_value,
                        const enum FrobMessageType expected_type,
                        const char* const expected_token) {
    struct frob_header hdr = {};
    const int ret = frob_header_extract(&buf, buf + bs - 1, &hdr);
    ck_assert_int_eq(ret, expected_return_value);
    ck_assert_int_eq(hdr.type, expected_type);
    ck_assert_str_eq(hdr.token, expected_token);
}

#define TEST_FRAME(Input, ExpectedRet, ExpectedP, ExpectedPe) do {\
    byte_t buf[] = Input;\
    test_frame(elementsof(buf), buf, ExpectedRet, OFFSET_OR_PTR(buf,ExpectedP), OFFSET_OR_PTR(lastof(buf),ExpectedPe));\
} while (0)
static void test_frame(const size_t bs, byte_t buf[static bs],
                       const int expected_return_value,
                       const byte_t* const expected_p, const byte_t* const expected_pe) {
    struct frob_frame_fsm_state st = {.p = buf, .pe = buf + bs};
    const int x = frob_frame_process(&st);
    ck_assert_int_eq(x, expected_return_value);
    ck_assert_ptr_eq(st.p, expected_p);
    ck_assert_ptr_eq(st.pe, expected_pe);
}

#suite frame_parsing

#test simple_frame_parsed_correctly
    TEST_FRAME(STX "000102" FS "T1" FS ETX "e", 0, 1, -2);

#test frame_with_invalid_lrc_produces_error
    TEST_FRAME(STX "000102" FS "T1" FS ETX "&", EBADMSG, 1, -2);

#test empty_frame_is_handled_gracefully
    byte_t buf[0];
    struct frob_frame_fsm_state st = {.p = buf, .pe = buf};
    const int x = frob_frame_process(&st);
    ck_assert_int_eq(x, EAGAIN);
    ck_assert_ptr_eq(st.p, buf);
    ck_assert_ptr_null(st.pe);

#test incomplete_frame_returns_eagain
    TEST_FRAME(STX "000102", EAGAIN, 1, NULL);

#test any_junk_before_correct_frame_is_skipped
    TEST_FRAME("gar\0bage" STX "23AB" FS "T2" FS "170" FS "COMPANY" FS "SAMPLE MESSAGE" FS "02" FS ETX "y", 0, sizeof("gar\0bage"), -2);

#test incomplete_frame_can_be_resumed
    byte_t buf1[] = STX "000102" FS;
    struct frob_frame_fsm_state st = {.p = buf1, .pe = lastof(buf1)};
    int x = frob_frame_process(&st);
    ck_assert_int_eq(x, EAGAIN);
    ck_assert_ptr_eq(st.p, buf1 + 1);
    ck_assert_ptr_null(st.pe);

    byte_t buf2[] = "T1" FS;
    st.p = buf2;
    st.pe = lastof(buf2);
    x = frob_frame_process(&st);
    ck_assert_int_eq(x, EAGAIN);
    ck_assert_ptr_null(st.pe);
    ck_assert_ptr_eq(st.p, buf2);

    byte_t buf3[] = ETX "e";
    st.p = buf3;
    st.pe = lastof(buf3);
    x = frob_frame_process(&st);
    ck_assert_int_eq(x, 0);
    ck_assert_ptr_eq(st.p, buf3);
    ck_assert_ptr_eq(st.pe, buf3);

#suite header_parsing

#test simple_header_parsed_correctly
    TEST_HEADER3("000102" FS "T1" FS, 0, FROB_T1, "000102");

#test empty_token_is_rejected
    TEST_HEADER1("" FS "T1" FS, EBADMSG);

#test incomplete_header_is_rejected
    TEST_HEADER1("" FS "T1", EBADMSG);

#test short_token_is_padded
    TEST_HEADER3("AA" FS "M1" FS, 0, FROB_M1, "AA");

#test incomplete_hex_is_not_padded
    TEST_HEADER3("B" FS "S2" FS, 0, FROB_S2, "B");

#test incomplete_message_type_is_rejected
    TEST_HEADER1("" FS "T" FS, EBADMSG);

#test empty_message_type_is_rejected
    TEST_HEADER1("ABCDEF" FS "" FS, EBADMSG);

#test complete_but_non_existent_message_type_is_rejected
    TEST_HEADER1("123456" FS "T7" FS, EBADMSG);

#suite body_parsing

#test empty_body_is_handled
    byte_t buf[0];
    const byte_t* p = buf;
    union frob_body body = {}, empty = {};
    const int ret = frob_body_extract(FROB_T3, &p, p, &body);
    ck_assert_int_eq(ret, 0);
    ck_assert_ptr_eq(p, buf);
    ck_assert_mem_eq(&body, &empty, sizeof empty);

#suite utils

#test space_trimming_works_with_only_trailing_spaces
    char buf[] = "hello    ";
    ck_assert_str_eq(trim_whitespaces(buf), "hello");

#test space_trimming_works_with_only_leading_spaces
    char buf[] = "    hello";
    ck_assert_str_eq(trim_whitespaces(buf), "hello");

#test space_trimming_works
    char buf[] = "    hello    ";
    ck_assert_str_eq(trim_whitespaces(buf), "hello");

#test space_trimming_works_with_empty_string
    char buf[] = "";
    ck_assert_str_eq(trim_whitespaces(buf), "");

#test space_trimming_works_with_only_spaces
    char buf[] = "    ";
    ck_assert_str_eq(trim_whitespaces(buf), "");

#test space_trimming_works_with_no_spaces
    char buf[] = "hello";
    ck_assert_str_eq(trim_whitespaces(buf), "hello");

#suite serializing

static const struct frob_msg t1 = {
    .magic = FROB_MAGIC,
    .header = {
        .type = FROB_T1,
        .token = "12"
    }
}, d5 = {
    .magic = FROB_MAGIC,
    .header = {
        .type = FROB_D5,
        .token = "AAA"
    },
    .body.d5 = {
        .printer_cpl = 42,
        .printer_cpl2x = 42,
        .printer_cpl4x = 42,
        .printer_cpln = 42,
        .printer_h2 = true,
        .printer_h4 = true,
        .printer_inv = true,
        .printer_max_barcode_length = 42,
        .printer_max_qrcode_length = 42,
        .printer_max_bitmap_count = 42,
        .printer_max_bitmap_width = 42,
        .printer_max_bitmap_height = 42,
        .printer_aspect_ratio = 120,
        .printer_buffer_max_lines = 256,
        .display_lc = 4,
        .display_cpl = 20,
        .key_name = {
            .enter = "O",
            .cancel = "X",
            .check = "C",
            .backspace = "",
            .delete = "",
            .up = "^",
            .down = "v",
            .left = "<",
            .right = ">"
        },
        .device_topo = FROB_DEVICE_TYPE_ECR,
        .nfc = true,
        .ccr = true,
        .mcr = true,
        .bar = true
    }
};

#test simple_frame_serialized_correctly
    input_t buf[64];
    static const input_t expected[] = STX "12" FS "T1" FS ETX "e";
    const int ret = serialize(sizeof buf, buf, &t1);
    ck_assert_mem_eq(buf, expected, ret);
    ck_assert_int_eq(ret, sizeof expected - 1);

#test empty_buffer_is_handled
    input_t buf[0];
    const int ret = serialize(0, buf, &t1);
    ck_assert_int_eq(ret, -1);

#test buffer_too_small_is_handled
    input_t buf[3];
    const int ret = serialize(sizeof buf, buf, &t1);
    ck_assert_int_eq(ret, -1);

#test complex_frame_serialized_correctly
    input_t buf[256];
    const int ret = serialize(sizeof buf, buf, &d5);
    static const input_t expected[] = STX "AAA" FS "D5" FS "42" FS "42" FS "42"
            FS "42" FS "1" FS "1" FS "1" FS "42" FS "42" FS "42" FS "42" FS "42"
            FS "120" FS "256" FS "4" FS "20" FS "O" US "X" US "C" US "" US "" US
            "^" US "v" US "<" US ">" US FS "0" FS "1" FS "1" FS "1" FS "1" FS ETX "a";
    ck_assert_int_eq(ret, sizeof expected - 1);
    ck_assert_mem_eq(buf, expected, ret);
