#include "frob.h"
#include "utils.h"
#include "log.h"

#ifdef CK_MAX_ASSERT_MEM_PRINT_SIZE
#   undef CK_MAX_ASSERT_MEM_PRINT_SIZE
#endif
#define CK_MAX_ASSERT_MEM_PRINT_SIZE 256

#include <errno.h>
#include <unistd.h>

// We aren't testing actual I/O here, those functions are used only in the test
// fixtures and support code, so we can just abort on error.
#define XSYSCALL(Type, Func, ...) ({\
    const Type ret = Func(__VA_ARGS__);\
    if (ret == -1)\
        ck_abort_msg(#Func "(" #__VA_ARGS__ ") failed: %m");\
    ret;\
})
#define xpipe(...) XSYSCALL(int, pipe, ##__VA_ARGS__)
#define xclose(...) XSYSCALL(int, close, ##__VA_ARGS__)
#define xwrite(...) XSYSCALL(ssize_t, write, ##__VA_ARGS__)

// TODO: Can this be done during compilation time?
#define FILL_DUMMY_DATA(Buf) do {\
    for (size_t i = 0; i < elementsof(Buf); i++) \
        (Buf)[i] = (i % 0x5F) + 0x20;\
} while (0)

#define OFFSET_OR_PTR(Start, Value)\
    _Generic((Value),\
        int: (Start) + (intptr_t)(Value),\
        size_t: (Start) + (intptr_t)(Value),\
        void*: (Value)\
    )

static int write_data_to_pipe(const size_t l, const char data[static const l]) {
    int pfd[2];
    xpipe(pfd);
    xwrite(pfd[1], data, l);
    xclose(pfd[1]);
    return pfd[0];
}

#define TEST_HEADER1(Input, ExpectedRet)\
    TEST_HEADER3(Input, ExpectedRet, 0, "")
#define TEST_HEADER3(Input, ExpectedRet, ExpectedType, ExpectedToken)\
    test_header(elementsof(Input), (byte_t*)Input, ExpectedRet, ExpectedType, strtotoken(ExpectedToken, NULL, 16))
static void test_header(const size_t bs, const byte_t buf[static bs],
                        const int expected_return_value,
                        const enum FrobMessageType expected_type,
                        const token_t expected_token) {
    struct frob_header hdr = {};
    const int ret = frob_header_extract(&buf, buf + bs - 1, &hdr);
    ck_assert_int_eq(ret, expected_return_value);
    ck_assert_int_eq(hdr.type, expected_type);
    ck_assert_uint_eq(hdr.token, expected_token);
}

#define TEST_FRAME(Input, ExpectedRet, ExpectedP, ExpectedPe) do {\
    byte_t buf[] = Input;\
    test_frame(elementsof(buf), buf, ExpectedRet, OFFSET_OR_PTR(buf,ExpectedP), OFFSET_OR_PTR(lastof(buf),ExpectedPe));\
} while (0)
static void test_frame(const size_t bs, byte_t buf[static bs],
                       const int expected_return_value,
                       const byte_t* const expected_p, const byte_t* const expected_pe) {
    struct frob_frame_fsm_state st = {.p = buf, .pe = buf + bs};
    const int x = frob_frame_process(&st);
    ck_assert_int_eq(x, expected_return_value);
    ck_assert_ptr_eq(st.p, expected_p);
    ck_assert_ptr_eq(st.pe, expected_pe);
}

#define TEST_EREAD(Data, BufSize, ExpectedRet)\
    test_eread(sizeof Data, Data, BufSize, ExpectedRet)
#define TEST_EREAD_OK(Data, BufSize)\
    TEST_EREAD(Data, BufSize, sizeof Data)
static void test_eread(const size_t data_size, const char data[static const data_size], const size_t buf_size, const ssize_t expected_ret) {
    const int fd = write_data_to_pipe(data_size, data);
    input_t out[buf_size];
    const ssize_t r = eread(fd, sizeof out, out);
    ck_assert_int_eq(r, expected_ret);
    ck_assert_mem_eq(out, data, min(data_size, buf_size));
    if (data_size >= buf_size)
        ck_assert_int_eq(errno, EFBIG);
    xclose(fd);
}

#suite frame_parsing

#test simple_frame_parsed_correctly
    TEST_FRAME(STX "000102" FS "T1" FS ETX "e", 0, 1, -2);

#test frame_with_invalid_lrc_produces_error
    TEST_FRAME(STX "000102" FS "T1" FS ETX "&", EBADMSG, 1, -2);

#test empty_frame_is_handled_gracefully
    byte_t buf[0];
    struct frob_frame_fsm_state st = {.p = buf, .pe = buf};
    const int x = frob_frame_process(&st);
    ck_assert_int_eq(x, EAGAIN);
    ck_assert_ptr_eq(st.p, buf);
    ck_assert_ptr_null(st.pe);

#test incomplete_frame_returns_eagain
    TEST_FRAME(STX "000102", EAGAIN, 1, NULL);

#test any_junk_before_correct_frame_is_skipped
    TEST_FRAME("gar\0bage" STX "23AB" FS "T2" FS "170" FS "COMPANY" FS "SAMPLE MESSAGE" FS "02" FS ETX "y", 0, sizeof("gar\0bage"), -2);

#test incomplete_frame_can_be_resumed
    byte_t buf1[] = STX "000102" FS;
    struct frob_frame_fsm_state st = {.p = buf1, .pe = lastof(buf1)};
    int x = frob_frame_process(&st);
    ck_assert_int_eq(x, EAGAIN);
    ck_assert_ptr_eq(st.p, buf1 + 1);
    ck_assert_ptr_null(st.pe);

    byte_t buf2[] = "T1" FS;
    st.p = buf2;
    st.pe = lastof(buf2);
    x = frob_frame_process(&st);
    ck_assert_int_eq(x, EAGAIN);
    ck_assert_ptr_null(st.pe);
    ck_assert_ptr_eq(st.p, buf2);

    byte_t buf3[] = ETX "e";
    st.p = buf3;
    st.pe = lastof(buf3);
    x = frob_frame_process(&st);
    ck_assert_int_eq(x, 0);
    ck_assert_ptr_eq(st.p, buf3);
    ck_assert_ptr_eq(st.pe, buf3);

#suite header_parsing

#test simple_header_parsed_correctly
    TEST_HEADER3("000102" FS "T1" FS, 0, FROB_T1, "000102");

#test empty_token_is_rejected
    TEST_HEADER1("" FS "T1" FS, EBADMSG);

#test incomplete_header_is_rejected
    TEST_HEADER1("" FS "T1", EBADMSG);

#test short_token_is_padded
    TEST_HEADER3("AA" FS "M1" FS, 0, FROB_M1, "AA");

#test incomplete_hex_is_not_padded
    TEST_HEADER3("B" FS "S2" FS, 0, FROB_S2, "B");

#test incomplete_message_type_is_rejected
    TEST_HEADER1("" FS "T" FS, EBADMSG);

#test empty_message_type_is_rejected
    TEST_HEADER1("ABCDEF" FS "" FS, EBADMSG);

#test complete_but_non_existent_message_type_is_rejected
    TEST_HEADER1("123456" FS "T7" FS, EBADMSG);

#suite body_parsing

#test empty_body_is_handled
    byte_t buf[0];
    const byte_t* p = buf;
    union frob_body body = {}, empty = {};
    const int ret = frob_body_extract(FROB_T3, &p, p, &body);
    ck_assert_int_eq(ret, 0);
    ck_assert_ptr_eq(p, buf);
    ck_assert_mem_eq(&body, &empty, sizeof empty);

#suite utils

#test space_trimming_works_with_only_trailing_spaces
    char buf[] = "hello    ";
    ck_assert_str_eq(trim_whitespaces(buf), "hello");

#test space_trimming_works_with_only_leading_spaces
    char buf[] = "    hello";
    ck_assert_str_eq(trim_whitespaces(buf), "hello");

#test space_trimming_works
    char buf[] = "    hello    ";
    ck_assert_str_eq(trim_whitespaces(buf), "hello");

#test space_trimming_works_with_empty_string
    char buf[] = "";
    ck_assert_str_eq(trim_whitespaces(buf), "");

#test space_trimming_works_with_only_spaces
    char buf[] = "    ";
    ck_assert_str_eq(trim_whitespaces(buf), "");

#test space_trimming_works_with_no_spaces
    char buf[] = "hello";
    ck_assert_str_eq(trim_whitespaces(buf), "hello");

#test eread_file
    TEST_EREAD_OK("Hello, this is some test data", 64);

#test eread_empty_file
    TEST_EREAD_OK(((char[0]){}), 64);

#test eread_empty_file_into_empty_buffer
    TEST_EREAD(((char[0]){}), 0, -1);

#test eread_big_file
    char buf[64 * 1024];
    FILL_DUMMY_DATA(buf);
    TEST_EREAD_OK(buf, sizeof buf + 1);

#test eread_file_into_buffer_with_the_same_size_as_the_file
    char buf[64 * 1024];
    FILL_DUMMY_DATA(buf);
    TEST_EREAD(buf, sizeof buf, -1);

#test eread_file_works_with_empty_buffer
    TEST_EREAD("Hello, this is some test data", 0, -1);

#test eread_file_works_with_small_buffer
    TEST_EREAD("Hello, this is some test data", 1, -1);

#suite serializing

static const struct frob_msg t1 = {
    .magic = FROB_MAGIC,
    .header = {
        .type = FROB_T1,
        .token = 0x12
    }
}, d5 = {
    .magic = FROB_MAGIC,
    .header = {
        .type = FROB_D5,
        .token = 0xAAA
    },
    .body.d5 = {
        .printer_cpl = 42,
        .printer_cpl2x = 42,
        .printer_cpl4x = 42,
        .printer_cpln = 42,
        .printer_h2 = true,
        .printer_h4 = true,
        .printer_inv = true,
        .printer_max_barcode_length = 42,
        .printer_max_qrcode_length = 42,
        .printer_max_bitmap_count = 42,
        .printer_max_bitmap_width = 42,
        .printer_max_bitmap_height = 42,
        .printer_aspect_ratio = 120,
        .printer_buffer_max_lines = 256,
        .display_lc = 4,
        .display_cpl = 20,
        .key_name = {
            .enter = "O",
            .cancel = "X",
            .check = "C",
            .backspace = "",
            .delete = "",
            .up = "^",
            .down = "v",
            .left = "<",
            .right = ">"
        },
        .device_topo = FROB_DEVICE_TYPE_ECR,
        .nfc = true,
        .ccr = true,
        .mcr = true,
        .bar = true
    }
};

#test simple_frame_serialized_correctly
    input_t buf[64];
    static const input_t expected[] = STX "12" FS "T1" FS ETX "e";
    const int ret = serialize(sizeof buf, buf, &t1);
    ck_assert_mem_eq(buf, expected, ret);
    ck_assert_int_eq(ret, sizeof expected - 1);

#test empty_buffer_is_handled
    input_t buf[0];
    const int ret = serialize(0, buf, &t1);
    ck_assert_int_eq(ret, -1);

#test-exit(1) buffer_too_small_is_handled
    input_t buf[3];
    serialize(sizeof buf, buf, &t1);

#test complex_frame_serialized_correctly
    input_t buf[256];
    const int ret = serialize(sizeof buf, buf, &d5);
    static const input_t expected[] = STX "AAA" FS "D5" FS "42" FS "42" FS "42"
            FS "42" FS "1" FS "1" FS "1" FS "42" FS "42" FS "42" FS "42" FS "42"
            FS "120" FS "256" FS "4" FS "20" FS "O" US "X" US "C" US "" US "" US
            "^" US "v" US "<" US ">" US FS "0" FS "1" FS "1" FS "1" FS "1" FS ETX "a";
    ck_assert_int_eq(ret, sizeof expected - 1);
    ck_assert_mem_eq(buf, expected, ret);
